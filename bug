# =============================
# File: api_utils.py
# Purpose: Encapsulate all Genie API interactions and polling utilities
# =============================

from __future__ import annotations
import os
import time
from typing import Dict, Any, Optional, Tuple
import requests
import pandas as pd


class GenieAPI:
    """Lightweight client for Databricks Genie Space APIs.

    Defaults are read from environment variables but can be overridden.
    - DATABRICKS_HOST (e.g., https://adb-xxxx.azuredatabricks.net)
    - DATABRICKS_TOKEN (user or app token with access)
    - GENIE_SPACE_ID (the Space ID)
    """

    def __init__(
        self,
        host: Optional[str] = None,
        token: Optional[str] = None,
        space_id: Optional[str] = None,
        timeout: int = 60,
    ) -> None:
        self.host = (host or os.environ.get("DATABRICKS_HOST") or "").rstrip("/")
        self.token = token or os.environ.get("DATABRICKS_TOKEN")
        self.space_id = space_id or os.environ.get("GENIE_SPACE_ID")
        self.timeout = timeout

        if not self.host:
            raise ValueError("DATABRICKS_HOST is required (env DATABRICKS_HOST or constructor arg)")
        if not self.token:
            raise ValueError("DATABRICKS_TOKEN is required (env DATABRICKS_TOKEN or constructor arg)")
        if not self.space_id:
            raise ValueError("GENIE_SPACE_ID is required (env GENIE_SPACE_ID or constructor arg)")

        self._session = requests.Session()
        self._session.headers.update(
            {
                "Authorization": f"Bearer {self.token}",
                "Content-Type": "application/json",
            }
        )

    # -----------------------------
    # Conversation APIs
    # -----------------------------
    def start_conversation(self, content: str) -> Tuple[str, str]:
        """Start a conversation in the space and return (conversation_id, message_id)."""
        url = f"{self.host}/api/2.0/genie/spaces/{self.space_id}/start-conversation"
        r = self._session.post(url, json={"content": content}, timeout=self.timeout)
        r.raise_for_status()
        payload = r.json()
        return payload.get("conversation_id"), payload.get("message_id")

    def get_message(self, conversation_id: str, message_id: str) -> Dict[str, Any]:
        url = f"{self.host}/api/2.0/genie/spaces/{self.space_id}/conversations/{conversation_id}/messages/{message_id}"
        r = self._session.get(url, timeout=self.timeout)
        r.raise_for_status()
        return r.json()

    def wait_for_message(self, conversation_id: str, message_id: str, poll_seconds: float = 2.0, max_wait_seconds: int = 180) -> Dict[str, Any]:
        """Poll the message until status is COMPLETED or FAILED. Returns the final message JSON."""
        deadline = time.time() + max_wait_seconds
        last_status = None
        while True:
            msg = self.get_message(conversation_id, message_id)
            status = (msg.get("status") or "").strip().upper()
            if status != last_status:
                last_status = status
            if status in {"COMPLETED", "FAILED"}:
                return msg
            if time.time() > deadline:
                raise TimeoutError(f"Timed out waiting for message status, last status={status}")
            time.sleep(poll_seconds)

    # -----------------------------
    # Attachment / Query APIs
    # -----------------------------
    def execute_attachment(self, conversation_id: str, message_id: str, attachment_id: str) -> Dict[str, Any]:
        url = f"{self.host}/api/2.0/genie/spaces/{self.space_id}/conversations/{conversation_id}/messages/{message_id}/attachments/{attachment_id}/execute-query"
        r = self._session.post(url, timeout=self.timeout)
        r.raise_for_status()
        return r.json()

    def get_query_result(self, conversation_id: str, message_id: str, attachment_id: str) -> Dict[str, Any]:
        url = f"{self.host}/api/2.0/genie/spaces/{self.space_id}/conversations/{conversation_id}/messages/{message_id}/attachments/{attachment_id}/query-result"
        r = self._session.get(url, timeout=self.timeout)
        r.raise_for_status()
        return r.json()

    def wait_for_query(self, conversation_id: str, message_id: str, attachment_id: str, poll_seconds: float = 2.0, max_wait_seconds: int = 300) -> Dict[str, Any]:
        """Poll until query state SUCCEEDED or FAILED. Returns final result JSON."""
        deadline = time.time() + max_wait_seconds
        while True:
            res = self.get_query_result(conversation_id, message_id, attachment_id)
            state = (
                res
                .get("statement_response", {})
                .get("status", {})
                .get("state", "")
            ).strip().upper()
            if state in {"SUCCEEDED", "FAILED"}:
                return res
            if time.time() > deadline:
                raise TimeoutError(f"Timed out waiting for query result, last state={state}")
            time.sleep(poll_seconds)

    # -----------------------------
    # Helpers
    # -----------------------------
    @staticmethod
    def first_sql_from_message(msg: Dict[str, Any]) -> Optional[str]:
        attachments = msg.get("attachments") or []
        if not attachments:
            return None
        query = (attachments[0] or {}).get("query") or {}
        return query.get("query")

    @staticmethod
    def first_attachment_id(msg: Dict[str, Any]) -> Optional[str]:
        attachments = msg.get("attachments") or []
        if not attachments:
            return None
        return (attachments[0] or {}).get("attachment_id")

    @staticmethod
    def result_to_dataframe(result_json: Dict[str, Any]) -> pd.DataFrame:
        sr = result_json.get("statement_response", {})
        manifest = sr.get("manifest", {})
        schema = (manifest.get("schema", {}) or {})
        columns = schema.get("columns", [])
        col_names = [c.get("name", f"col_{i}") for i, c in enumerate(columns)]
        data_array = (sr.get("result", {}) or {}).get("data_array", [])
        return pd.DataFrame(data_array, columns=col_names)


# Convenience function for one-shot question -> dataframe

def run_genie_question(content: str, *, host: Optional[str] = None, token: Optional[str] = None, space_id: Optional[str] = None) -> Tuple[pd.DataFrame, Dict[str, Any]]:
    client = GenieAPI(host=host, token=token, space_id=space_id)
    conv_id, msg_id = client.start_conversation(content)
    final_msg = client.wait_for_message(conv_id, msg_id)

    # Optional: show generated SQL if present
    sql_text = GenieAPI.first_sql_from_message(final_msg)

    attachment_id = GenieAPI.first_attachment_id(final_msg)
    if not attachment_id:
        raise RuntimeError("No attachment_id found on the message. The assistant may not have produced a query.")

    client.execute_attachment(conv_id, msg_id, attachment_id)
    final_result = client.wait_for_query(conv_id, msg_id, attachment_id)

    df = GenieAPI.result_to_dataframe(final_result)
    return df, {"conversation_id": conv_id, "message_id": msg_id, "attachment_id": attachment_id, "sql": sql_text}


# =============================
# File: app.py
# Purpose: Streamlit UI that imports and uses api_utils.py
# =============================

import os
import streamlit as st
from api_utils import GenieAPI

# --- Configuration ---
# Prefer .env or environment variables to avoid hardcoding
# Required: DATABRICKS_HOST, DATABRICKS_TOKEN, GENIE_SPACE_ID

st.set_page_config(page_title="GENIE", layout="wide")
st.title("GENIE")

# Small helper to validate env
missing = [k for k in ("DATABRICKS_HOST", "DATABRICKS_TOKEN", "GENIE_SPACE_ID") if not os.environ.get(k)]
if missing:
    st.warning(
        "Missing required environment variables: " + ", ".join(missing) +
        ". Set them to run the app."
    )

question = st.text_input("Enter your question here")
if st.button("QUERY", use_container_width=True):
    if not question.strip():
        st.warning("Please enter a question")
        st.stop()

    try:
        client = GenieAPI()  # picks from env
        with st.spinner("Starting conversation…"):
            conv_id, msg_id = client.start_conversation(question)

        with st.spinner("Waiting for assistant to prepare the query…"):
            final_msg = client.wait_for_message(conv_id, msg_id)

        sql_text = GenieAPI.first_sql_from_message(final_msg)
        if sql_text:
            st.subheader("Generated SQL")
            st.code(sql_text, language="sql")
        else:
            st.info("No SQL text found in the assistant's response.")

        attachment_id = GenieAPI.first_attachment_id(final_msg)
        if not attachment_id:
            st.error("No attachment/result to execute.")
            st.stop()

        with st.spinner("Executing query…"):
            client.execute_attachment(conv_id, msg_id, attachment_id)

        with st.spinner("Fetching results…"):
            result_json = client.wait_for_query(conv_id, msg_id, attachment_id)

        df = GenieAPI.result_to_dataframe(result_json)
        st.success("Done")
        st.dataframe(df, use_container_width=True)

    except Exception as e:
        st.error(f"Error: {e}")
